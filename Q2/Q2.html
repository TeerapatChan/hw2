<!DOCTYPE html>
<html>
  <head>
    <style>
      path.link {
        fill: none;
        stroke: #666;
        stroke-width: 1.5px;
      }

      .link.dashed {
        stroke: green;
        stroke-dasharray: 4 2;
      }

      .link.solid {
        stroke: gray;
        stroke-dasharray: none;
      }

      circle {
        stroke: #fff;
        stroke: black;
        stroke-width: 1.5px;
      }

      .node circle.pinned {
        stroke: #000;
        stroke-width: 3px;
        fill: orange;
      }

      text {
        fill: #000;
        font: bold 10px sans-serif;
        pointer-events: none;
      }
    </style>
    <meta charset="utf-8" />
    <title></title>
  </head>

  <body>
    <script type="text/javascript" src="../lib/d3.v5.min.js"></script>
    <script>
      d3.dsv(",", "board_games.csv", function (d) {
        return {
          source: d.source,
          target: d.target,
          value: +d.value,
        };
      })
        .then(function (data) {
          var links = data;

          var nodes = {};

          links.forEach((l) => {
            l.source =
              nodes[l.source] ||
              (nodes[l.source] = { name: l.source, degree: 0, fixed: false });
            l.target =
              nodes[l.target] ||
              (nodes[l.target] = { name: l.target, degree: 0, fixed: false });

            l.source.degree++;
            l.target.degree++;

            l.type = l.value == 1 ? "dashed" : "solid";
          });

          var width = 1200,
            height = 700;

          const degree = d3.extent(d3.values(nodes), (d) => d.degree);
          const radius = d3
            .scaleLinear()
            .domain(d3.extent(degree))
            .range([5, 20]);
          const color = d3.scaleSequential(d3.interpolateBlues).domain(degree);

          var force = d3
            .forceSimulation()
            .nodes(d3.values(nodes))
            .force("link", d3.forceLink(links).distance(100))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("x", d3.forceX())
            .force("y", d3.forceY())
            .force("charge", d3.forceManyBody().strength(-250))
            .alphaTarget(1)
            .on("tick", tick);

          var svg = d3
            .select("body")
            .append("svg")
            .attr("width", width)
            .attr("height", height);

          // add the links
          var path = svg
            .append("g")
            .selectAll("path")
            .data(links)
            .enter()
            .append("path")
            .attr("class", function (d) {
              return "link " + d.type;
            });

          // define the nodes
          var node = svg
            .selectAll(".node")
            .data(force.nodes())
            .enter()
            .append("g")
            .attr("class", "node")
            .call(
              d3
                .drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended)
            )
            .on("click", function (d) {
              d.fixed = true;
              d3.select(this).select("circle").classed("pinned", true);
            })
            .on("dblclick", function (d) {
              d.fixed = false;
              d3.select(this).select("circle").classed("pinned", false);
            });

          // add the nodes
          node
            .append("circle")
            .attr("id", function (d) {
              return d.name.replace(/\s+/g, "").toLowerCase();
            })
            .attr("r", (d) => radius(d.degree))
            .attr("fill", (d) => color(d.degree));

          // add the labels
          node
            .append("text")
            .attr("y", -8)
            .attr("x", 8)
            .text((d) => d.name);

          // add the curvy lines
          function tick() {
            path.attr("d", function (d) {
              var dx = d.target.x - d.source.x,
                dy = d.target.y - d.source.y,
                dr = Math.sqrt(dx * dx + dy * dy);
              return (
                "M" +
                d.source.x +
                "," +
                d.source.y +
                "A" +
                dr +
                "," +
                dr +
                " 0 0,1 " +
                d.target.x +
                "," +
                d.target.y
              );
            });

            node.attr("transform", function (d) {
              return "translate(" + d.x + "," + d.y + ")";
            });
          }

          function dragstarted(d) {
            if (!d3.event.active) force.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
          }

          function dragged(d) {
            d.fx = d3.event.x;
            d.fy = d3.event.y;
          }

          function dragended(d) {
            if (!d3.event.active) force.alphaTarget(0);
            if (d.fixed == true) {
              d.fx = d.x;
              d.fy = d.y;
            } else {
              d.fx = null;
              d.fy = null;
            }
          }
        })
        .catch(function (error) {
          console.log(error);
        });
    </script>
  </body>
</html>
